%% name = NodePattern::Parser

%% {
  attr_reader :ast

  def s(type, children)
    NodePattern::Node.new(type, children)
  end
}

spaces = /[\s]*/
nodetype = /[a-zA-Z][a-zA-Z0-9_-]*/

root = spaces start spaces

start = &. statement:c { @ast = c  }

statement = node | any

exprs = expr:e1 /[\s]+/ exprs:e2 { [e1, *e2] } |
        expr:e { [e] }

expr = node | any | literal

node = '(' spaces < nodetype > spaces ')' { s(:node, [text]) } |
       '(' spaces < nodetype > spaces exprs:e spaces ')' {
          children = [text, *e]
          s(:node, children)
        }

any = '_' {
  s(:any, [])
}

literal = symbol # | int | float | string

symbol = ':' < sym_text > { s(:literal, [text.to_sym]) }

# TODO
sym_text = /\w+/
